// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';

// Use Vite environment variables
export const SUPABASE_URL = import.meta.env.VITE_SUPABASE_URL as string;
export const SUPABASE_PUBLISHABLE_KEY = import.meta.env.VITE_SUPABASE_ANON_KEY as string;

// Import the supabase client like this:
// import { supabase } from "@/integrations/supabase/client";

// Database settings interface
export interface Settings {
  id: string;
  company_code: string;
  company_name: string;
  address: string;
  phone: string;
  email: string;
  website: string;
  tax_id: string;
  header_text: string;
  footer_text: string;
  base_location_id: string;
  base_customer_id: string;
  default_code_type: 'customer' | 'type' | 'company';
  created_at: string;
  updated_at: string;
}

// UI settings interface for local storage
export interface UISettings {
  dark_mode: boolean;
  auto_save: boolean;
  enable_manual_barcode: boolean;
}

// Helper function for settings operations
export const settings = {
  getSettings: async (): Promise<Settings | null> => {
    const { data, error } = await supabase
      .from('settings')
      .select('*')
      .limit(1);
    
    if (error) throw error;
    return data ? data[0] : null;
  },
  
  updateSettings: async (settingsData: Partial<Settings>): Promise<void> => {
    const { error } = await supabase
      .from('settings')
      .update(settingsData)
      .eq('id', settingsData.id);
    
    if (error) throw error;
  },
  
  createSettings: async (settingsData: Omit<Settings, 'id'>): Promise<void> => {
    const { error } = await supabase
      .from('settings')
      .insert([settingsData]);
    
    if (error) throw error;
  }
};

// Export the supabase client
export const supabase = createClient<Database>(SUPABASE_URL, SUPABASE_PUBLISHABLE_KEY);

// Custom query functions for tables not in the Database type
export const getCustomTable = (tableName: string) => {
  // Using any type to bypass TypeScript's type checking for dynamic table names
  return supabase.from(tableName as any);
};

// Helper function to safely handle data from custom tables
export const safelyParseCustomData = <T>(data: any): T[] => {
  if (!data || !Array.isArray(data)) {
    return [] as T[];
  }
  return data as T[];
};

// Interface for the missing inventory item from the Supabase database
export interface MissingInventoryItem {
  id: string;
  inventory_id: string;
  customer: string;
  project: string;
  last_seen_location: string;
  last_seen_gate: string;
  last_seen_timestamp: string;
  status: string;
  missing_days: number;
}

// Interface for the movement item from the Supabase database
export interface MovementItem {
  id: string;
  inventory_id: string;
  gate_id: string;
  movement_type: string;
  timestamp: string;
  location: string;
  previous_location: string;
  customer: string;
  project: string;
}

// New helper function to properly handle custom query requests
export const fetchCustomTableData = async <T>(
  tableName: string, 
  options?: {
    filters?: Record<string, any>;
    range?: { from?: Date; to?: Date; field?: string };
  }
): Promise<{ data: T[]; error: any }> => {
  try {
    let query = getCustomTable(tableName).select('*');
    
    // Apply date range filters if provided
    if (options?.range) {
      const { from, to, field = 'timestamp' } = options.range;
      
      if (from) {
        query = query.gte(field, from.toISOString());
      }
      
      if (to) {
        query = query.lte(field, to.toISOString());
      }
    }
    
    // Apply any additional filters
    if (options?.filters) {
      Object.entries(options.filters).forEach(([key, value]) => {
        if (value !== undefined && value !== null) {
          query = query.eq(key, value);
        }
      });
    }
    
    const { data, error } = await query;
    
    if (error) {
      console.error(`Error fetching ${tableName}:`, error);
      return { data: [], error };
    }
    
    return { data: safelyParseCustomData<T>(data), error: null };
  } catch (err) {
    console.error(`Unexpected error fetching ${tableName}:`, err);
    return { data: [], error: err };
  }
};
